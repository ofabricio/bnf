[Test]
Test '...' string.

[Give]
\ \
''
'\''
'one'
'\'one\''
'one\'two\'three'
'\'one\'two\'three\''

[When]
root = '\\' sp '\\\\'r (nl str)*
 str = '\'([^\'\\\\]|\\\\.)*\''r

[Then]
[Group]
    [Ident] \
    [Ident] \
    [Ident] ''
    [Ident] '\''
    [Ident] 'one'
    [Ident] '\'one\''
    [Ident] 'one\'two\'three'
    [Ident] '\'one\'two\'three\''


[Test]
Test that '...'r is a regular expression.

[Give]
One    Two

[When]
root = 'One' '\s+'r 'Two'

[Then]
[Group]
    [Ident] One
    [Ident]     
    [Ident] Two


[Test]
Test that '...'i prevents a token from being emitted.

[Give]
OneTwoThreeFour

[When]
root = 'One'i 'Two' 'Three'i 'Four'

[Then]
[Group]
    [Ident] Two
    [Ident] Four


[Test]
Test that "And" is using a new variable when looping, instead of "out" directly.

[Give]
acbaab

[When]
root = ( 'a' 'a' | '.'ri ) *

[Then]
[Group]
    [Ident] a
    [Ident] a


[Test]
Test the * quantifier. It must match zero, one or many.

[Give]
OneTwo OneOneTwo Two

[When]
root = 'One'* 'Two' ' 'i 'One'* 'Two' ' 'i 'One'* 'Two'

[Then]
[Group]
    [Ident] One
    [Ident] Two
    [Ident] One
    [Ident] One
    [Ident] Two
    [Ident] Two


[Test]
Test the + quantifier. It must match one or many.

[Give]
OneTwo OneOneTwo Two

[When]
root = 'One'+ 'Two' ' 'i 'One'+ 'Two' ' 'i ( 'One'+ | 'Two' )

[Then]
[Group]
    [Ident] One
    [Ident] Two
    [Ident] One
    [Ident] One
    [Ident] Two
    [Ident] Two


[Test]
Test the ? quantifier. It must match zero or one.

[Give]
OneTwo Two OneOneTwo

[When]
root = 'One'? 'Two' ' 'i 'One'? 'Two' ' 'i 'One'? 'OneTwo'

[Then]
[Group]
    [Ident] One
    [Ident] Two
    [Ident] Two
    [Ident] One
    [Ident] OneTwo


[Test]
MATCH must match the tree and return the matched token.
Notice the difference between 'One'+ with and without MATCH.

[Give]
OneOne OneOne

[When]
root = MATCH('One'+) ' 'i 'One'+

[Then]
[Group]
    [Ident] OneOne
    [Ident] One
    [Ident] One


[Test]
Test MATCH and the ? quantifier.

[Give]
OneTwo Two OneOneTwo

[When]
root = MATCH('One'? 'Two' ' 'i 'One'? 'Two' ' 'i 'One'? 'OneTwo')

[Then]
[Ident] OneTwo Two OneOneTwo


[Test]
Test MATCH and the + quantifier.

[Give]
OneTwo OneOneTwo Two

[When]
root = MATCH('One'+ 'Two' ' 'i 'One'+ 'Two' ' 'i ( 'One'+ | 'Two' ))

[Then]
[Ident] OneTwo OneOneTwo Two


[Test]
Test MATCH and the * quantifier.

[Give]
OneTwo OneOneTwo Two

[When]
root = MATCH('One'* 'Two' ' 'i 'One'* 'Two' ' 'i 'One'* 'Two')

[Then]
[Ident] OneTwo OneOneTwo Two


[Test]
Test NOT.

[Give]
abc

[When]
root = NOT('b') NOT('a') NOT('c')?

[Then]
[Group]
    [Ident] a
    [Ident] b


[Test]
Test NOT and + quantifier.

[Give]
"Two"

[When]
root = '"' NOT('"')+ '"'

[Then]
[Group]
    [Ident] "
    [Ident] T
    [Ident] w
    [Ident] o
    [Ident] "


[Test]
Test that NOT will match until 'Two', not including it in the result.

[Give]
OneOneTwoOne

[When]
root = MATCH(NOT('Two')+)

[Then]
[Ident] OneOne


[Test]
Test that NOT matches until EOF.

[Give]
OneOneTwoOne

[When]
root = MATCH(NOT('Three')+)

[Then]
[Ident] OneOneTwoOne


[Test]
Test that NOT returns false if it doesn't advance.

[Give]
OneTwo

[When]
root = NOT('One')

[Then]
[Group]


[Test]
Test SCAN.

[Give]
Hello, {name}! You have {count} messages.

[When]
root = SCAN(tag)
 tag = MATCH('{' '\w+'r '}')

[Then]
[Group]
    [Ident] {name}
    [Ident] {count}


[Test]
Test Type.

[Give]
6+5*(4+3)*2

[When]
expr   = term   ROOT('+'):Opr expr | term
term   = factor ROOT('*'):Opr term | factor
factor = '('i expr ')'i | value:Val
value  = '\d+'r

[Then]
[Opr] +
    [Val] 6
    [Opr] *
        [Val] 5
        [Opr] *
            [Opr] +
                [Val] 4
                [Val] 3
            [Val] 2


[Test]
Test Type and GROUP.

[Give]
abcde

[When]
root = 'a' GROUP('b' 'c' 'd'):G 'e'

[Then]
[Group]
    [Ident] a
    [G]
        [Ident] b
        [Ident] c
        [Ident] d
    [Ident] e


[Test]
Test Type and strings.

[Give]
2+3

[When]
root = num '+':Opr num
 num = '\w+'r:Val

[Then]
[Group]
    [Val] 2
    [Opr] +
    [Val] 3
